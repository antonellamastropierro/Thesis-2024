# OBJECTIVE: To create and customize a virtual species living in Alpine conditions in Europe
# PART 1: Import environmental data/variables
# PART 2: Isolate alpine env. variables using Europe alpine shapefile
# PART 3: Run correlation/VIF test on variables to test for multicollinearity
# PART 4: Retrieve mean and sd values for used bio variables
# PART 5: Create virtual species with specified conditions

################################################################################
# PRELIMINARY STEP 1: INSTALL AND LOAD PACKAGES

install.packages("virtualspecies")
install.packages("raster")
install.packages("geodata")
install.packages("usdm")
install.packages("tidyr")
install.packages("dplyr")
install.packages("sf")
install.packages("rnaturalearth")
install.packages("rnaturalearthdata")
install.packages("ggplot2")
install.packages("viridis")

# geographic data and analysis
library(raster)

# mapping geographical data
library(rnaturalearth)
library(rnaturalearthdata)

# uncertainty analysis for species distribution models
library(usdm)

# data manipulation
library(tidyr)
library(dplyr)

#plotting
library(ggplot2)

# read shapefiles
library(sf)

# generate virtual species distributions
library(virtualspecies)

# color palette creation
library(viridis)

#-------------------------------------------------------------------------------
# PRELIMINARY STEP 2: SET WORKING DIRECTORY

setwd("~/UNIBO/Internship and Thesis/R Thesis Project/Thesis Data")

# LEGEND:
  # bio = bio variables
  # EUR = Europe
  # alp = alpine climate locations
  # df = dataframe
 

################################################################################
# PART 1: Import environmental data/variables
# Purpose: to import environmental data to be used for observation of vs suitability
# data source: worldclim
# package: raster

# retrieve the 19 bio variables from their saved location in the working directory
# create a character vector of all 19 variables in order to combine and create a spatraster
worldclim_files <- list.files(path="wc30", pattern = "bio", full.names = TRUE)
# the files downloaded from Worldclim are 30s resolution dating from 1970 to 2000
## REMEMBER TO RENAME THE TIFS IN THE FILE TO MAKE LIFE EASIER
print(worldclim_files)

# reorder the files before converting to a spatraster
worldclim_files <- worldclim_files[c(1, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)]

# confirm reorder
print(worldclim_files)

# create a spatraster of the 19 bio variables
worldclim <- rast(worldclim_files)

names(worldclim)
# plot bio variable 1 (mean temp) for confirmation
plot(worldclim[[1]])
# var = variable (i.e. temp, prec)  bio = all 19
# res = resolution
# path = default is current working directory

# look at the characteristics of the bio variables
print(worldclim)
# class: SpatRaster
# dimensions  : 1080, 2160, 19  (nrow, ncol, nlyr)
# resolution  : 0.1666667, 0.1666667  (x, y)
# extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
# coord. ref. : lon/lat WGS 84 (EPSG:4326)
# when turned to RasterLayer: # cells = 2332800

# show the current manes of the uploaded bio variables
names(worldclim)
# Per the WorldClimate website:
# BIO1 = Annual Mean Temperature
# BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))
# BIO3 = Isothermality (BIO2/BIO7) (×100)
# BIO4 = Temperature Seasonality (standard deviation ×100)
# BIO5 = Max Temperature of Warmest Month
# BIO6 = Min Temperature of Coldest Month
# BIO7 = Temperature Annual Range (BIO5-BIO6)
# BIO8 = Mean Temperature of Wettest Quarter
# BIO9 = Mean Temperature of Driest Quarter
# BIO10 = Mean Temperature of Warmest Quarter
# BIO11 = Mean Temperature of Coldest Quarter
# BIO12 = Annual Precipitation
# BIO13 = Precipitation of Wettest Month
# BIO14 = Precipitation of Driest Month
# BIO15 = Precipitation Seasonality (Coefficient of Variation)
# BIO16 = Precipitation of Wettest Quarter
# BIO17 = Precipitation of Driest Quarter
# BIO18 = Precipitation of Warmest Quarter
# BIO19 = Precipitation of Coldest Quarter

# to turn into RasterLayer
# worldclim_raster <- raster(worldclim)

# don't change the names of the bio variables yet because some of them will be
# ...eliminated

################################################################################
# PART 2: Isolate alpine env. variables using Europe alpine shapefile
# Purpose: using a shapefile with Alpine conditions, we can filter out alpine conditions
#... located only in Europe and isolate the worldclimate bio variables located
# ... in the European alpine areas in order to isolate only alpine bio conditions
# data source: https://figshare.com/articles/dataset/Global_distribution_and_bioclimatic_characterization_of_alpine_biomes/11710002
# SUBPARTS:
# A: Upload Alpine shapefile and modify to only Europe
# B: Crop the worldclimate bio variables to match extent of Alpine shapefile
# C: Isolate the bio variables located only in the Alpine shapefile polygons

#-------------------------------------------------------------------------------
# A: Upload Alpine shapefile and modify to only Europe

# upload the Alpine shapefile from where it's saved
alp <- st_read("global alp shpfile/global_alpine_30m_v1_1.shp")

# look at a description of the shapefile
print(alp)
# Geometry Type: Multipolygon
# Dimension: XY
# Extent: xmin: -179.9997 ymin: -55.42102 xmax: 179.9997 ymax: 70.47041
# Coords: +proj=longlat +datum=WGS84 +no_defs
# Column Names: continent, name, area_km2, geometry

# the project will focus only on the alpine climate in Europe

# to filter out only Europe alpine areas
alp_EUR <- filter(alp, continent == "Europe")

# look at the head and tail of the Europe shapefile to confirm only
# ... Europe polygons are included
head(alp_EUR)
tail(alp_EUR)
# Europe Extent: xmin: -6.498323 ymin: 36.98059 xmax: 66.89637 ymax: 70.47041

# visualize the new Europe shapefile
plot(alp_EUR$geometry)
# the geometry column is tagged as it contains the polygons
# not filtering out just the geometry column would result in three of the same plots
# shows the alpine locations in Europe

# add a background map to the shapefile for better visualization
# retrieve europe background map from rnaturalearth
EUR <- ne_countries(continent = "europe")

# plot for confirmation
plot(EUR$geometry)

# CONFIRM SHAPEFILE COORDS ARE THE SAME
if (st_crs(alp_EUR) == st_crs(EUR)) {print("Equal")}

# plot the two shapefiles and specify the extent to match the alpine Europe sf extent
ggplot() + 
  geom_sf(data = alp_EUR, fill = 'blue', color = 'blue', alpha = 0.5) +
  geom_sf(data = EUR, color = 'black', alpha = 0.5) + 
  coord_sf(xlim = c(-9.779958, 66.89637), ylim = c(36.98059, 70.47041)) +
  theme_minimal()
## MODIFY PLOT LATER FOR AESTHETICS

dev.off()

#-------------------------------------------------------------------------------
# B: Crop the worldclimate bio variables to match extent of Alpine shapefile

# In order to compare the bio variables and Europe alpine shapefile, their
# ...coords must be the same
# show only the CRS (Coordinate Reference System) of the Europe alpine shapefile
print(st_crs(alp_EUR))

# show the CRS of the worldclimate variables
print(st_crs(worldclim))

# if unsure, a logical function can be used
if (st_crs(alp_EUR) == st_crs(worldclim)) { print("Equal")}

# the CRSs are equal
# but to make the coords the same
st_crs(alp_EUR) = st_crs(worldclim)
print(st_crs(alp_EUR))
# another method: st_transform(alpine_EUR, crs(worldclim))

# Crop out the bio variable spatraster to match the extent of the Europe alpine shapefile
bio_EUR <- crop(worldclim, alp_EUR)
# crop function(file to be cropped, file with the extent needed for cropping)

# visualize a plot to see if the cropping was successful
# I.E. index out bio variable 1 (annual avg temp) since spatraster is a combination of the 19 variables
plot(bio_EUR[[1]])
# the new worldclimate spatraster (bio_EUR) now has the same extent as the Europe alpine shapefile
#... and shows only Europe

dev.off()

#-------------------------------------------------------------------------------
# C: Isolate the bio variables located only in the Alpine shapefile polygons
# the European extent is shown but we need to isolate the bio variables to only
# ... the values located in the alpine climate areas

# use the mask function to isolate only the Europe alpine values of the bio variables
bio_EUR_alp<- mask(bio_EUR, alp_EUR, inverse = FALSE)
# mask function(file to me masked, file to mask with)

# plot one of the variables to see if isolation/masking was successful
plot(bio_EUR_alp[[1]])
# the plot now shows the isolated alpine climate areas in the bio variable plot
## REMEMBER AESTHETICS FOR PLOTS (TITLE, LEGEND, COLOR)

# to plot the isolated alpine bio variables (i.e. mean temp) against a map of Europe

# first convert raster layer to data frame
bio_EUR_alp_df <- as.data.frame(bio_EUR_alp[[1]], xy=TRUE)
colnames(bio_EUR_alp_df)

# plot the mean temp raster with the Europe shapefile
ggplot() +
  geom_tile(data = bio_EUR_alp_df, aes(x = x, y = y, fill = wc2.1_30s_bio_1), alpha = 0.7) +
  geom_sf(data = EUR, fill = NA, color = 'black', size = 1) +
  coord_sf(xlim = c(-9.779958, 66.89637), ylim = c(36.98059, 70.47041)) +
  theme_minimal()
## REMEMBER TO MODIFY PLOTS FOR AESTHETICS

dev.off()

################################################################################
# PART 3: Run correlation/VIF test on variables to test for multicollinearity
# Purpose: to eliminate any unneeded variables by comparing the independent variables
# ... and testing for mulitcollinearity in order to avoid redundancy and overfitting
# package: usdm
# variance inflation factor (VIF): measure of the degree of multicollinearity
# ... of one regressor with the other regressors in a linear regression

# Test the already isolated European alpine-specified variables
# vifcor() function runs a correlation test and VIF test
vifcor(bio_EUR_alp, th=0.7, keep = NULL, method = 'pearson')
# th = threshold (0.9 is default)
# keep = if you want to keep a variable regardless of correlation
# method = method used to calculate pairwise correlation (pearson is default)

# The VIF/Correlation test returned 8 bio variables: 2, 3, 8, 9, 10, 15, 18, 19
# BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))
# BIO3 = Isothermality (BIO2/BIO7) (×100)
# BIO8 = Mean Temperature of Wettest Quarter
# BIO9 = Mean Temperature of Driest Quarter
# BIO10 = Mean Temperature of Warmest Quarter
# BIO15 = Precipitation Seasonality (Coefficient of Variation)
# BIO18 = Precipitation of Warmest Quarter
# BIO19 = Precipitation of Coldest Quarter

# therefore, these are the 8 bio variables we want to use when creating the alpine VS

# now that the variables that do not have a colinearity problem are found,
# ... filter out/eliminate the unneeded variables
bio_EUR_alp <- subset(bio_EUR_alp, c(2, 3, 8, 9, 10, 15, 18, 19))

# use the names () function to confirm the changes
names(bio_EUR_alp)
# it now shoes only have the 8 bio variables identified in the VIF test

# change the names of the variables to make it easier
names(bio_EUR_alp) <- c("Mean Diurnal Range", "Isothermality", "Mean Temp of Wettest Quarter",
                        "Mean Temp of Driest Quarter", "Mean Temp of Warmest Quarter",
                        "Precip Seasonality", "Precip of Warmest Quarter",
                              "Precip of Coldest Quarter")

# confirm the names are changed
names(bio_EUR_alp)
# the names now align with the worldclimate descriptions of the variables
# ...in the masked biovariable Europe alpine spatraster


# however, the unmasked Europe biovariable spatraster will be the one used when plotting the VS

# do the same filtering with the unmasked bio variable spatraster
# ... because this raster will be the one used for the VS mapping
bio_EUR <- subset(bio_EUR, c(2, 3, 8, 9, 10, 15, 18, 19))

# confirm filtering has been successful
names(bio_EUR)
# now shows only the 8 variables identified in the VIF test

# change the names of the variables to match the ones in the masked Europe alpine spatraster
names(bio_EUR) <- c("Mean Diurnal Range", "Isothermality", "Mean Temp of Wettest Quarter",
                    "Mean Temp of Driest Quarter", "Mean Temp of Warmest Quarter",
                    "Precip Seasonality", "Precip of Warmest Quarter",
                    "Precip of Coldest Quarter")

# confirm that the names have changed
names(bio_EUR)

### QUESTION: these are specific to alpine VS in Europe. Is that okay or should I
# ...run the collinearity test for global alpine conditions?

################################################################################
# PART 4: Retrieve mean and sd values for used bio variables
# Purpose: in order to create a custom alpine VS

# the spatraster containing the values at each pixel need to be converted to dataframes
# ...in order to retrieve the mean and sd values for each of the 7 bio variable
# ...to input into our custom alpine VS

# convert the masked Europe alpine climate-specific spatraster into a dataframe
bio_EUR_alp_df <- as.data.frame(bio_EUR_alp)

# view the dataframe
glimpse(bio_EUR_alp_df)
# now it's a dataframe, showing all the values of each of the 8 variables located
#... specifically in the alpine climate areas of Europe

# Get the means and SDs of each variable to input later into the VS

# to get the means of all 8 variables at the same time
colMeans(bio_EUR_alp_df)
# Mean Diurnal Range = 6.669699
# Isothermality = 25.478149
# Mean Temperature of Wettest Quarter = 3.109187
# Mean Temperature of Driest Quarter = -4.250315
# Mean Temperature of Warmest Quarter = 7.434767
# Precipitation Seasonality = 27.493933
# Precipitation of Warmest Quarter = 275.162391
# Precipitation of Coldest Quarter = 251.743403

# retrieve SD of all 8 variables
summarize_all(bio_EUR_alp_df, sd)
# Mean Diurnal Range = 1.179638
# Isothermality = 3.471046
# Mean Temperature of Wettest Quarter = 5.261975
# Mean Temperature of Driest Quarter = 6.65543
# Mean Temperature of Warmest Quarter = 1.898872
# Precipitation Seasonality = 7.56867
# Precipitation of Warmest Quarter = 72.66963
# Precipitation of Coldest Quarter = 146.808

# the means and SDs have now been determined for the necessary 8 variables
# these values will be used to create a custom alpine-specific VS

################################################################################
# PART 5: Create virtual species with specified conditions
# Purpose: using the alpine-specific values for each of bio variable, a alpine-specific
# VS can be created
# SUBSECTIONS:
# A: create env. suitability plot
# B: create presence/absence plot
# C: Sample occurrence points

#-------------------------------------------------------------------------------
# A: Create Environmental Suitability Plot

# first create parameters for alpine species using the mean and SD values retrieved
# ... from part 4
# the raster used will be the unmasked European biovariable raster to show the
# ...VS suitability in relation to all of Europe
alp_pmtrs <- formatFunctions(x=bio_EUR,
                             "Mean Diurnal Range" = c(fun = 'dnorm', mean = 6.669699, sd=1.179638),
                             "Isothermality" = c(fun = "dnorm", mean = 25.478149, sd = 3.471046),
                             "Mean Temp of Wettest Quarter"= c(fun = "dnorm", mean = 3.109187, sd = 5.261975),
                             "Mean Temp of Driest Quarter"= c(fun = "dnorm", mean = -4.250315, sd = 6.65543),
                             "Mean Temp of Warmest Quarter" = c(fun = 'dnorm', mean = 7.434767, sd = 1.898872),
                             "Precip Seasonality"= c(fun = "dnorm", mean = 27.493933, sd = 7.56867),
                             "Precip of Warmest Quarter"= c(fun = "dnorm", mean = 275.162391, sd = 72.66963),
                             "Precip of Coldest Quarter"= c(fun = "dnorm", mean = 251.743403, sd = 146.808))

# input the alpine-specific parameters to generate an alpine-specific VS
alp_vs_1 <- generateSpFromFun(raster.stack = bio_EUR,
                            parameters = alp_pmtrs,
                            plot = TRUE)
# shows the env. suitability for Europe specific to alpine species (scale of 0 to 1)

dev.off()

# to save the first alpine VS generated
save(alp_vs_1, file = "VS/alp_vs_1")

# to load the alpine VS
# load(file = "VS/alp_vs_1")

# to visualize the response functions that were inputted
plotResponse(alp_vs_1)
# all gaussian curves. Visualized the peak suitability values for each of the 7 variables

dev.off()
#-------------------------------------------------------------------------------
# B: Create presence/absence plot

# use converttoPA() function to convert the suitability plot into a binary presence/absence plot
alp_pa_1 <- convertToPA(alp_vs_1, beta = 0.7, alpha = -0.07, plot = FALSE)
# beta = inflection point of curve
# lower beta = wider distribution range (increase probability of finding suitable conditions)
# higher beta = smaller distribution range (decrease probability of finding suitable conditions)
# alpha = slope of curve ranging from linear to logistic to threshold like
# species prevalence: number of places occupied by the species
#... out of the total number of available places

# for alpine vs maybe good to make higher beta
# maybe better to specify species prevalence to 3% since I found documents saying
# ... Alpine occupies 3% of world
# alp_pa <- convertToPA(alp_vs, beta = 'random', alpha = -0.07, species.prevalence = 0.03,
# plot = TRUE)
alp_pa_1
# probabilistic method = logistic
# species prevalence = 0.00042, which makes sense

# plot the presence/absence raster
plot(alp_pa_1$pa.raster)
# for suitability: alp_pa$suitab.raster
# for prob. of occurrence: alp_pa$probability.of.occurrence

dev.off()


#-------------------------------------------------------------------------------
# C: Sample occurrence points
# Purpose: to sample presence only points from P/A plot
# Presence only shows realized niche

# to show the number of cells
raster(alp_pa_1$pa.raster)
# number of cells = 36973636. This equals the max number of present points

# the sampleoccurrence function allows to sample n # of points from the presence points
alp_presence_1 <- sampleOccurrences(alp_pa_1, n = 100, type = "presence only",
                                    sample.prevalence = 0.9, correct.by.suitability = TRUE)
# n = # of points to sample, meaning 100 of the 36973636 were sampled
# correct by suitability = TRUE so that detection is dependent on suitability.
  # less suitable cells will have a lower probability of presence than higher suitable cells

str(alp_presence_1)
alp_presence_1
# Type: presence only
# Number of points: 100
# No sampling bias
# Detection probability: 
# Probability: 1
# Corrected by suitability: FALSE
# Probability of identification error (false positive): 0


dev.off()
