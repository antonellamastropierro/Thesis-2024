# SECTION III: UNBIASED ALPINE HV

# PRELIMINARY 1: Standardize Bio Variable Raster Layers
# PRELIMINARY 2: Create Hypervolume Functions
# OBJECTIVE 1: Extract Unbiased Sampling Bio Variables for Analysis
# OBJECTIVE 2: Create Unbiased Sample HV and Observe Volume Change over Number of Samples for 10 Simulations

################################################################################
# SECTION II RECAP: BIASED ALPINE VS
# Created distance from roads and sampling probability rasters for the AOI
# Extracted the sampling probability for the 200 presence-only unbiased samples
# Filtered out the unbiased sampling occurrences with 100% sampling probability (within 1km from road)
# Retrieved Biased Sampling Points (29 biased points out of 200 unbiased points)

################################################################################
# LEGEND:
# AOI = area of interest (European Alps mountain range)
# bio = CHELSA environmental variables
# alp = alpine climate locations
# df = dataframe
# pmtrs = parameters
# vs = virtual species
# pa = presence/absence
# occ = occurrences
# rstr = raster
# std = standardized
################################################################################
# PRELIMINARY 1: Standardize Bio Variable Raster Layers
# Purpose: the selected bio variables currently have different means, standard deviations,
  #...and methods of measurements (i.e. temp (degree C), precipitation(mm)).
  # Standardizing all the bio variables to have a mean=0 and SD=1 allows for consistency
  #...throughout all bio variable measurements for better comparison.
  # The bio variable raster layers should be standardized before bio variable extraction to eliminate
  #...continuously having to standardize them after extraction.

# Standardization is completed through Z-score transformation so that:
  # mean = 0
  # SD = 1
# Z-score transformation equation: Z = (x-u)/o
  # x = data point value
  # u = mean value
  # o = standard deviation

# convert bio variable spatraster (bio_AOI) into a raster stack with 7 layers representing each
  #...bio variable
bio_AOI_stk <- stack(bio_AOI)

#confirm number of layers in bio variable raster stack
nlayers(bio_AOI_stk)
# 7 layers confirmed

# empty list to store the standardized raster layers
bio_AOI_stk_std <- list()

# create a loop that inputs the z-score equation into each of the 7 bio variable rasters
for (i in 1:nlayers(bio_AOI_stk)){
  bio_AOI_stk_std[[i]] <- (bio_AOI_stk[[i]] - cellStats(bio_AOI_stk[[i]], 'mean')) / cellStats(bio_AOI_stk[[i]], 'sd') 
  }

# convert the standardized list into a rasterstack
bio_AOI_stk_std <- stack(bio_AOI_stk_std)

# confirm layers are standardized
cellStats(bio_AOI_stk_std, 'mean')
cellStats(bio_AOI_stk_std, 'sd')
# all layers have mean = 0 and SD = 1

# rename names in standardized stack so aware that these are the standardized layers
names(bio_AOI_stk_std) <- c("Annual Mean Temp Std", "Isothermality Std", "Temp Seasonality Std",
                            "Mean Temp of Wettest Quarter Std", "Mean Temp of Driest Quarter Std",
                            "Annual Precip Std", "Precip Seasonality Std")

# confirm changes
names(bio_AOI_stk_std)

# save the standardized rasterstack
writeRaster(bio_AOI_stk_std, file = "VS_HV/bio_AOI_stk_std.tif")
# to load it
# bio_AOI_stk_std <- stack("VS_HV/bio_AOI_stk_std.tif")

# now there is a bio raster stack containing the 7 standardized bio variables
#-------------------------------------------------------------------------------
# PRELIMINARY 2: Create Hypervolume Functions
# create the following functions:
  # 1. calculate the hypervolume
  # 2. calculate the hypervolume accumulation of a subset of data and check for convergence based on defined criteria

# Function 1: HV calculation function (df = dataframe)
calc_hv <- function(df) {
  occ_hv <- hypervolume_gaussian(df) # function calculates hv using kernel density estimation
  return(occ_hv@Volume) # returns the volume component of the hypervolume
}

# Function 2: Calculation of the hypervolume accumulation of a subset of the data
calc_accum <- function(x, no, epsilon = 0.01) {
  # x = dataframe (unbiased/biased points)
  # no = parameter that specifies how many random rows will be selected from x
  # epsilon = convergence threshold
  
  # Initializes with a random row within the dataframe
  fx <- x %>% sample_n(size = 1) 
  volumes <- 0  # where to store the subset HV volumes
  num_occ <- 0  # store the subset number of occurrences
  converged <- FALSE # initialize indicating convergence is false
  
  for (i in 1:1000) {
    
    fx <- x %>% # Starts with a random row in the dataset (x)
      sample_n(size = no) %>% # Choose 'no' (parameter) random values
      bind_rows(fx) %>% # binds the selected rows to 'fx'
      distinct() # makes sure the values are all unique (have not been selected before)
    
    # Calculate the subset hypervolume (I already created the function calc_hv)
    hv <- calc_hv(fx)
    
    # Save the hypervolume volume and number of occurrences
    volumes <- c(volumes, hv)
    num_occ <- c(num_occ, nrow(fx))
    
    # Check for convergence (if the difference between one volume and the volume before it is less than epsilon (0.01), convergence = T)
    if (length(volumes) > 1 && abs(volumes[length(volumes)] - volumes[length(volumes) - 1]) < epsilon) {
      converged <- TRUE
      break
    }
    
    # Stop when the subset has the same number of occurrences as the original set
    if (nrow(fx) == nrow(x)) {
      break
    }
  }
  result <- bind_cols(volumes = volumes, num_occ = num_occ)   
  return(list(result=result, converged = converged))
}

################################################################################
# OBJECTIVE 1: Extract Unbiased Sampling Bio Variables for Analysis
# Purpose: The isolated bio variables of the actual realized niche and first 100 samples
  #... are needed for HV creation and analysis
# Realized Niche = Presence Values from the Presence-Absence Plot (alp_pa_1)
  # PART A: Retrieve the Total Realized Niche Bio Variables (Presence Points)
  # PART B: Retrieve First 200 Sampled Occurrences Bio Variables

#-------------------------------------------------------------------------------
# PART A: Retrieve the Total Realized Niche Bio Variables (Presence Points)
# CONFIRM IF THIS PART IS EVEN NECESSARY - EXTRACTING BIO VARIABLES OF TOTAL
  # REALIZED NICHE

# convert virtual species into a raster layer
# alp_pa_1_rstr <- raster(alp_pa_1$pa.raster)
# presence/absence is now a raster layer with values 0 (absence) and 1 (presence)

# freq(alp_pa_1_rstr$lyr.1)
# Absence (0) = 314133
# Presence (1) = 16504
# NaN = 593779 <- masked areas of raster

# the standardized bio variable values need to be retrieved for each presence point

# convert each standardized bio variable (7 total) into individual raster layers
# bio1_rstr_std <- bio_AOI_stk_std[[1]]
# bio2_rstr_std <- bio_AOI_stk_std[[2]]
# bio3_rstr_std <- bio_AOI_stk_std[[3]]
# bio4_rstr_std <- bio_AOI_stk_std[[4]]
# bio5_rstr_std <- bio_AOI_stk_std[[5]]
# bio6_rstr_std <- bio_AOI_stk_std[[6]]
# bio7_rstr_std <- bio_AOI_stk_std[[7]]


# to compare the bio variables with the presence values, combine all the raster layers
# trn_rstr_1 <- stack(alp_pa_1_rstr, bio1_rstr_std, bio2_rstr_std, bio3_rstr_std,
                 #   bio4_rstr_std, bio5_rstr_std, bio6_rstr_std, bio7_rstr_std)


# confirm all layers were added
# nlayers(trn_rstr_1)
# 8 layers total

# convert total realized niche raster to dataframe
# trn_df_1 <- as.data.frame(trn_rstr_1, xy=TRUE)

# find the name of the presence/absence column
# glimpse(trn_df_1)
# presence/absence column = lyr.1

# filter out the presence-only values (lyr.1 = 1)
# trn_df_1 <- filter(trn_df_1, lyr.1 == 1)
# only presence points = total realized niche values

# trn_df_1 = a dataframe containing all the bio variable values located in
#...actual realized niche
# glimpse(trn_df_1)

# remove lyr.1 column and coordinates
# trn_df_1 <- trn_df_1[ , -1:-3]
# glimpse(trn_df_1)
# 672 rows (presence-only points)
# 7 columns (7 bio variables)

# now trn_df_1 consists of dataframe of the bio variable values of the total realized niche

# confirm mean = 0
# summary(trn_df_1_std)

# confirm sd = 1
# summary(sd(trn_df_1_std))

#-------------------------------------------------------------------------------
# PART B: Extract Unbiased Sampling Bio Variables for Analysis

# convert the standardized bio variables raster stack into a dataframe with their coordinates
# can also do bio_AOI_pts_std <- as.data.frame(bio_AOI_stk_std, xy=T), but results with NAs
bio_AOI_pts_std <- rasterToPoints(bio_AOI_stk_std)
bio_AOI_df_std <- as.data.frame(bio_AOI_pts_std)
# dataframe contains all coordinates and their respective standardized bio variables in the AOI

# retrieve a dataframe of the 200 sampled occurrences and their coordinates
# the real and observed columns are not needed
alp_occ_1_df <- alp_occ_1$sample.points[ , -c(3,4)]

# the bio variable and 200 sample occurrence dataframes can be merged by their coordinates
# before merging the two dataframes by coordinates confirm the coordinate decimal places are the same
# round to the same decimal places so you get the bio values for all 672 samples
bio_AOI_df_std$x <- round(bio_AOI_df_std$x, 5)
bio_AOI_df_std$y <- round(bio_AOI_df_std$y, 5)
alp_occ_1_df$x <- round(alp_occ_1_df$x, 5)
alp_occ_1_df$y <- round(alp_occ_1_df$y, 5)

# merge the 200 sampled occurrences with the bio variables by their coordinates
# now that the coords are aligned, merge dataframes together by coords (x,y)
bio_occ_1_df <- merge(bio_AOI_df_std, alp_occ_1_df, by = c("x", "y"))

glimpse(bio_occ_1_df)
# dataframe contains 200 observations (sample points) with their respective bio variable values

# now that the dataframes are merged, the coordinate columns can be eliminated
bio_occ_1_df <- bio_occ_1_df[ , c(-1,-2)]

# confirm remaining columns are all bio variables
glimpse(bio_occ_1_df)
# rows = 200 (occurrence samples)
# columns = 7 (bio variables)

# a dataframe containing the 200 unbiased sampled occurrences and bio variables has been created
################################################################################
# OBJECTIVE 3: Create Unbiased Sample HV and Observe Volume Change over Number of Samples for 10 Simulations
  # PART A: Retrieve a subsample of the unbiased occurrence points that matches the same
    #...sampling effort as the biased points
  # PART B: Run the unbiased HV calculations for 10 simulations
  # PART C: Plot the unbiased HV volume over number of samples
#------------------------------------------------------------------------------
# PART A: Retrieve a subsample of the unbiased occurrence points that matches the same
#...sampling effort as the biased points
# Purpose: the biased sampling resulted in the collection of only 24 out of 200 unbiased samples.
  # In order for better comparison of the unbiased and biased HVs, the unbiased and biased HV
  #...should be calculated from similar sampling efforts (similar amount of samples)

# Retrieve rows from the unbiased and biased samplings
nrow(bias_pts) # 29
nrow(unbias_pts) # 200
# create a stop that equates to the number of biased sampled collected with an additional 20%
  #...of the biased samples collected
stop <-  ceiling(nrow(bias_pts) + 0.2 * (nrow(bias_pts)))
# result is a stopping point of 35 samples (amount of unbiased samples to be retrieved)

# Retrieve a random subsample of 35 points from the unbiased points
bio_occ_1_df_sub <- bio_occ_1_df[sample(nrow(bio_occ_1_df), stop), ]
# now the unbiased points contain 35 randomly selected points from the unbiased point dataset

# save the random subsample
save(bio_occ_1_df_sub, file = "VS_HV/bio_occ_1_df_sub")
# load("VS_HV/bio_occ_1_df_sub")

#-------------------------------------------------------------------------------
# PART B: Run the Unbiased HV Calculations for 10 simulations
# Purpose: using the two HV calculation functions created, the unbiased HV volume
  #....over number of samples can be created and run for 10 simulations

# store number of simulations
num_sim <- 10

# list of the occurrences to be tested (start at 5, by 5, until 35)
n_occ_list <- c(seq(from = 10, to = stop, by = 10), stop)

# List to store the simulations
sim_list <- list()

# vector to store convergence information
convg_info <- vector("logical", num_sim)

# Simulation Loop
for (sim in 1:num_sim) {
  
  list_output_occ <- list()
 
  for (i in seq_along(n_occ_list)) {
    result <- calc_accum(bio_occ_1_df_sub, n_occ_list[i])
    nelly <- result$result
    converged <- result$converged
    
    list_output_occ[[i]] <- nelly
    
    }
  
  # Store convergence information for this simulation iteration
  convg_info[sim] <- converged
  
  # Add the occurrence list to the simulation list
  sim_list[[sim]] <- list_output_occ
}


# View the convergence information
print(convg_info)

# Combine all simulations into one dataframe
combined_df <- do.call(rbind, lapply(seq_along(sim_list), function(sim) {
  do.call(rbind, lapply(sim_list[[sim]], function(df) {
    df$sim <- sim
    df
  }))
}))

# view resulting dataframe
combined_df

#--------------------------------------------------------------------------------
# PART C: Plot the average unbiased HV volume over number of samples from the 10 Simulations

# Mean predictions (LOESS): x sequence 
x_seq <- seq(min(combined_df$num_occ), max(combined_df$num_occ), length.out = 100)
loess_predictions <- lapply(unique(combined_df$num_occ), function(n) {
  preds <- sapply(sim_list, function(lista) {
    loess_fit <- loess(volumes ~ num_occ, data = do.call(rbind, lista))
    predict(loess_fit, newdata = data.frame(num_occ = n))
  })
  data.frame(num_occ = n, hv_mean = mean(preds, na.rm = TRUE))
})
predizioni_media <- do.call(rbind, loess_predictions)

# PLOT
ggplot() +
  geom_smooth(data = combined_df, aes(x = num_occ, y = volumes, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  geom_line(data = predizioni_media, aes(x = num_occ, y = hv_mean), 
            color = "deeppink", size = 1.2) +
  labs(title = "Hypervolume Mean: Unbiased (10 Simulations)",
       x = "Number of Occurrences",
       y = "Hypervolume Volume") +
  theme_minimal()
# the graph depicts the average HV volume over number of samples. Convergence was
  #...not achieved in any of the simulations
